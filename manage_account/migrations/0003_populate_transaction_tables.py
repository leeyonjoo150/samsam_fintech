# Generated by Django 5.2.5 on 2025-09-15 02:40
# manage_account/migrations/0003_populate_transaction_tables.py
# 수많은 고생끝에 완성한 데이터 마이그레이션 파일이다.
# models.py에 정의된 새로운 모델의 필드와 기존 모델의 데이터 type이 다르면 문제가 많으니 처음부터 신중히 고려하여 디자인 해야한다
# 특히, ('txn_date', models.DateTimeField(auto_now_add=True, verbose_name='거래날짜')), 
#                                        auto_now_add=True로 설정하면 객체 생성 시점의 시간이 자동으로 입력되어, 데이터 마이그레이션 시 원하는 날짜로 설정할 수 없다.
#
from django.db import migrations
from django.db.migrations import SeparateDatabaseAndState # 이 줄을 추가
# from django.contrib.auth.models import User
from decimal import Decimal
from datetime import datetime, time  # datetime 모듈 추가
from django.utils import timezone  # timezone 모듈 추가
import pytz  # pytz 모듈 추가


# 데이터 마이그레이션을 위한 함수
def populate_data(apps, schema_editor):
    # 사용할 타임존을 설정합니다. (settings.py의 TIME_ZONE과 일치하는지 확인)
    tz_korea = pytz.timezone('Asia/Seoul')
    
    # Old model 가져오기 (기존 코드와 동일)
    OldTransaction = apps.get_model('dashboard', 'Transaction')
    
    # New models 가져오기 (기존 코드와 동일)
    Account = apps.get_model('manage_account', 'Account')
    AccountBookCategory = apps.get_model('manage_account', 'AccountBookCategory')
    TransactionAccount = apps.get_model('manage_account', 'TransactionAccount')
    
    # 사용자 모델을 프로젝트 설정에 맞게 가져옵니다.
    # 기존 코드: from django.contrib.auth.models import User
    # 변경 코드: apps.get_model('acc_auth', 'User')
    User = apps.get_model('acc_auth', 'User')

    # 'hl5buj' 사용자 인스턴스를 가져옵니다.
    try:
        user_instance = User.objects.get(user_name='hl5buj')
    except User.DoesNotExist:
        print("Warning: 'hl5buj' does not exist. Please check the username.")
        return 

    # hl5buj의 계좌를 가져오거나 생성합니다.
    account_instance, created = Account.objects.get_or_create(
        acc_user_name=user_instance,
        acc_bank="KB국민은행",
        defaults={'acc_num': '123-45-67890', 'acc_pw': '1234'}
    )
    if created:
        print("Created new dummy account.")
    else:
        print("Using existing dummy account.")

    # 2. manage_account_accountbookcategory 테이블에 데이터 복사
    # 기존 Transaction 테이블의 category를 기반으로 중복 없이 Category 생성
    categories = OldTransaction.objects.values_list('category', flat=True).distinct()
    category_map = {}
    for cat_name in categories:
        category_obj, _ = AccountBookCategory.objects.get_or_create(
            cat_type=cat_name
        )
        category_map[cat_name] = category_obj
    print(f"Created {len(categories)} unique categories.")

    # 🏃‍♂️ running_balance 변수를 여기서 초기화합니다.
    running_balance = Decimal('0.00')

    # 모든 거래를 날짜 순서대로 정렬하여 가져오기
    all_transactions = OldTransaction.objects.order_by('transaction_date')
    
    # 일괄 생성을 위한 리스트
    transactions_to_create = []

    for old_trans in all_transactions:
        # 거래 유형에 따라 잔액을 계산
        if old_trans.transaction_type == '수입': # '수입' 필드 값이 '수입'인지 확인
            running_balance += old_trans.amount
        elif old_trans.transaction_type == '지출': # '지출' 필드 값이 '지출'인지 확인
            running_balance -= old_trans.amount
        
        category = None
        if old_trans.category:
            try:
                category = AccountBookCategory.objects.get(
                    # user=user_instance,
                    cat_type=old_trans.category
                )
            except AccountBookCategory.DoesNotExist:
                pass
        # Naive datetime 객체를 Aware하게 변환
        # Naive datetime 객체를 Aware하게 변환
        # 기존 코드: aware_date = timezone.make_aware(datetime.combine(old_trans.transaction_date, datetime.min.time()))
        # 수정 코드:
        naive_dt = datetime.combine(old_trans.transaction_date, time(12, 0, 0))
        aware_date = tz_korea.localize(naive_dt, is_dst=False)
                
        # TransactionAccount 인스턴스 생성
        new_trans = TransactionAccount(
            my_acc=account_instance,
            txn_side=old_trans.transaction_type,
            txn_date=aware_date,  # 변환된 날짜 객체 사용
            txn_amount=Decimal(old_trans.amount),
            txn_balance=running_balance,
            txn_cat=category,
            txn_cont=old_trans.description,
            cpart_acc=None
        )
        transactions_to_create.append(new_trans)
   
    # bulk_create를 사용하여 ORM의 자동화된 동작을 우회
    # 이는 auto_now_add=True 옵션을 무시하고 값을 강제로 넣을 수 있게 해줍니다.
    TransactionAccount.objects.bulk_create(transactions_to_create)
    print(f"Migrated {len(transactions_to_create)} transactions.")    
        
    #     TransactionAccount.objects.create(
    #         my_acc=account_instance,
    #         txn_side=old_trans.transaction_type,
    #         txn_date=old_trans.transaction_date,
    #         txn_amount=Decimal(old_trans.amount),
    #         # 계산된 잔액을 전달
    #         txn_balance=running_balance,
    #         txn_cat=category,
    #         txn_cont=old_trans.description,
    #         # cpart_acc는 None으로 두는 이전 코드가 맞습니다.
    #         cpart_acc=None
    #     )
    # print(f"Migrated {all_transactions.count()} transactions.")

def reverse_populate_data(apps, schema_editor):
    """
    데이터 마이그레이션을 되돌릴 때 실행되는 함수.
    새롭게 생성된 모든 TransactionAccount와 AccountBookCategory 객체를 삭제합니다.
    """
    TransactionAccount = apps.get_model('manage_account', 'TransactionAccount')
    AccountBookCategory = apps.get_model('manage_account', 'AccountBookCategory')

    # 생성된 데이터를 모두 삭제합니다.
    TransactionAccount.objects.all().delete()
    AccountBookCategory.objects.all().delete()
    

class Migration(migrations.Migration):

    dependencies = [
        # 다른 앱의 모델을 참조하므로 해당 앱의 마이그레이션에 의존성을 명시합니다.
        ('acc_auth', '0001_initial'),
        ('dashboard', '0001_initial'), # dashboard 앱의 초기 마이그레이션 파일
        ('manage_account', '0005_alter_transactionaccount_cpart_acc'), # manage_account 앱의 초기 마이그레이션 파일
        # 만약 User 모델을 사용한다면 auth 앱도 필요
    ]

    operations = [
        # 데이터베이스와 모델 상태를 분리하여 RunPython 실행
        SeparateDatabaseAndState(
            state_operations=[], # 상태 변경 없음
            database_operations=[ # 데이터베이스에 직접 영향을 주는 작업
                migrations.RunPython(populate_data, reverse_populate_data),
            ]
        ),
    ]